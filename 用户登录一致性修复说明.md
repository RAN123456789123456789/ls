# 用户登录一致性修复说明

## 问题描述

**问题现象：**
- 每次登录同一微信账号时，都被识别为不同的账户
- 用户信息不一致，每次登录都显示为新用户

**根本原因：**
1. 查询用户时只使用了自定义的 `openId` 字段
2. 云开发数据库在启用权限控制时会自动添加 `_openid` 字段作为查询条件
3. 当 `openId`（可能是临时值）和 `_openid`（微信官方唯一标识）不一致时，查询不到已存在的用户
4. 导致每次登录都创建新用户，而不是找到已存在的用户

## 修复方案

### 核心改进

**优先使用云开发的 `_openid` 作为用户唯一标识**

1. **查询用户时**：
   - 直接使用 `collection.get()` 查询当前用户（云开发会自动添加 `_openid` 条件）
   - 这样可以确保同一微信账号每次登录都能找到同一用户
   - 如果 `openId` 不一致，会自动更新 `openId` 字段以保持一致性

2. **保存用户时**：
   - 同样优先使用 `_openid` 查询已存在的用户
   - 如果找到用户，更新信息；如果没找到，创建新用户
   - 自动同步 `openId` 字段，确保数据一致性

### 修改的函数

1. **`getUserFromDatabase()`** - 从数据库获取用户信息
2. **`saveUserToDatabase()`** - 保存用户信息到数据库
3. **`updateUserProfile()`** - 更新用户头像和名称

## 修复后的效果

✅ **同一微信账号每次登录都能找到同一用户**
- 使用云开发的 `_openid`（微信官方唯一标识）作为主要查询条件
- 确保同一微信账号每次登录都能找到同一用户记录

✅ **自动同步 openId 字段**
- 如果发现 `openId` 不一致，会自动更新 `openId` 字段
- 保持数据一致性，避免重复用户

✅ **兼容旧数据**
- 如果通过 `_openid` 查询不到，会尝试用 `openId` 查询
- 确保旧数据也能正常使用

## 使用说明

### 测试步骤

1. **清除小程序数据**（模拟首次登录）
   - 在微信开发者工具中：工具 -> 清除缓存 -> 清除数据缓存

2. **登录小程序**
   - 授权登录，查看控制台日志
   - 应该会创建新用户

3. **再次登录**（模拟第二次登录）
   - 清除缓存后再次登录
   - 应该能找到已存在的用户，而不是创建新用户

4. **检查数据库**
   - 在云开发控制台查看 `user` 集合
   - 同一微信账号应该只有一条用户记录

### 注意事项

1. **权限控制**：
   - 确保云开发数据库的 `user` 集合启用了权限控制
   - 权限设置建议：仅创建者可读写

2. **数据迁移**：
   - 如果数据库中已有重复用户（相同 `_openid` 但不同 `openId`）
   - 修复后的代码会自动更新 `openId` 字段
   - 但建议手动检查并合并重复数据

3. **临时 openId**：
   - 如果使用临时 openId（`temp_xxx`），每次登录时临时 openId 可能不同
   - 修复后的代码会自动同步 `openId` 字段，确保数据一致性
   - 但建议使用真实的微信 openId（通过后端API获取）

## 代码变更说明

### 查询逻辑变更

**修改前：**
```typescript
// 只使用 openId 查询
const result = await userCollection.where({
    openId: targetOpenId
}).get();
```

**修改后：**
```typescript
// 优先使用 _openid 查询（云开发自动添加）
let result = await userCollection.get();

// 如果查询到数据，检查是否有匹配的用户
if (result.data && result.data.length > 0) {
    // 优先查找 openId 匹配的用户
    let userData = result.data.find((user: DBUserInfo) => user.openId === targetOpenId);
    
    // 如果没找到 openId 匹配的，取第一条（因为权限控制，只会返回当前用户的数据）
    if (!userData) {
        userData = result.data[0];
        // 如果 openId 不一致，更新 openId 字段
        if (userData.openId !== targetOpenId) {
            await userCollection.doc(userData._id).update({
                data: { openId: targetOpenId }
            });
        }
    }
}
```

## 相关文档

- `用户数据唯一性分析.md` - 详细分析用户唯一性机制
- `数据库索引配置说明.md` - 数据库索引配置指南

